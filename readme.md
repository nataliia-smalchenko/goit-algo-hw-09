# Порівняння динамічного та жадібного алгоритмів

## Результати тестування для номіналу [1, 2, 5, 10, 25, 50]

```
Кількість коштів: 2
Жадібний алгоритм: {2: 1}
Динамічне програмування: {2: 1}
Жадібний алгоритм: 0.0005124580347910523
Динамічне програмування: 0.0009518329752609134

Кількість коштів: 12
Жадібний алгоритм: {10: 1, 2: 1}
Динамічне програмування: {10: 1, 2: 1}
Жадібний алгоритм: 0.0005392500315792859
Динамічне програмування: 0.002806500007864088

Кількість коштів: 23
Жадібний алгоритм: {10: 2, 2: 1, 1: 1}
Динамічне програмування: {10: 2, 2: 1, 1: 1}
Жадібний алгоритм: 0.0006259169895201921
Динамічне програмування: 0.005413000006228685

Кількість коштів: 95
Жадібний алгоритм: {50: 1, 25: 1, 10: 2}
Динамічне програмування: {50: 1, 25: 1, 10: 2}
Жадібний алгоритм: 0.0004242080030962825
Динамічне програмування: 0.028733332990668714

Кількість коштів: 113
Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1}
Динамічне програмування: {50: 2, 10: 1, 2: 1, 1: 1}
Жадібний алгоритм: 0.0006469170330092311
Динамічне програмування: 0.06143854197580367

Кількість коштів: 2414
Жадібний алгоритм: {50: 48, 10: 1, 2: 2}
Динамічне програмування: {50: 48, 10: 1, 2: 2}
Жадібний алгоритм: 0.0005620000301860273
Динамічне програмування: 1.1251245840103365

Кількість коштів: 21938
Жадібний алгоритм: {50: 438, 25: 1, 10: 1, 2: 1, 1: 1}
Динамічне програмування: {50: 438, 25: 1, 10: 1, 2: 1, 1: 1}
Жадібний алгоритм: 0.0006880000000819564
Динамічне програмування: 11.932882166991476
```

## Висновки

- Для даного номіналу монет [1, 2, 5, 10, 25, 50] і даних сум жадібний абгоритм та алгоритм динамічного програмування дають однаковий результат.
- Крім того, як показали тести, жадібний алгоритм працює набагато швидше. Його час близько 0.0005-0.0008 секунд. Його складність є константною _O(1)_, оскільки кількість виконаних операцій залежить тільки від кількості номіналів монет, який не змінюється для різних сум.
- У той же час швидкодія влгоритму динамічного програмування залежить від суми, тому складністю буде лінійною _O(n)_. Зокрема під час тестування було виявлено, як збільшується час:
  - Для 95 одиниць — 0.0287 секунд.
  - Для 113 одиниць — 0.0614 секунд.
  - Для 2414 одиниць — понад 1 секунду.
  - Для 21938 одиниць — майже 12 секунд.
- Отже, в даному випадку жадібний алгоритм є кращим вибором.

## Результати тестування для номіналу [1, 6, 9, 15]

```
Кількість коштів: 2
Жадібний алгоритм: {1: 2}
Динамічне програмування: {1: 2}
Жадібний алгоритм: 0.0006279170047491789
Динамічне програмування: 0.001096333027817309

Кількість коштів: 12
Жадібний алгоритм: {9: 1, 1: 3}
Динамічне програмування: {6: 2}
Жадібний алгоритм: 0.0006796660018153489
Динамічне програмування: 0.0031493750284425914

Кількість коштів: 23
Жадібний алгоритм: {15: 1, 6: 1, 1: 2}
Динамічне програмування: {15: 1, 6: 1, 1: 2}
Жадібний алгоритм: 0.0007584579871036112
Динамічне програмування: 0.006821083021350205

Кількість коштів: 95
Жадібний алгоритм: {15: 6, 1: 5}
Динамічне програмування: {15: 5, 9: 2, 1: 2}
Жадібний алгоритм: 0.000685499981045723
Динамічне програмування: 0.033101415960118175

Кількість коштів: 113
Жадібний алгоритм: {15: 7, 6: 1, 1: 2}
Динамічне програмування: {15: 7, 6: 1, 1: 2}
Жадібний алгоритм: 0.0007551669841632247
Динамічне програмування: 0.038725458027329296

Кількість коштів: 2414
Жадібний алгоритм: {15: 160, 9: 1, 1: 5}
Динамічне програмування: {15: 159, 9: 3, 1: 2}
Жадібний алгоритм: 0.0007442500209435821
Динамічне програмування: 1.1977681249845773

Кількість коштів: 21938
Жадібний алгоритм: {15: 1462, 6: 1, 1: 2}
Динамічне програмування: {15: 1462, 6: 1, 1: 2}
Жадібний алгоритм: 0.000782958057243377
Динамічне програмування: 13.064314541989006
```

# Висновки

- Навідміну від попереднього прикладу, дані номінали монет є "підступними", тому ми бачимо, що результати жадібного та динамічного програмування відрізняються для сум 12, 95, 2414.
- Динамічний алгоритм знаходить у цьому випадку результат із найменшою загальною кількістю монет. Тому, якжо важливо отримати результат із найменшою кількістю монет, то для даного номіналу [1, 6, 9, 15] краще обрати алгоритм динамічного програмування.
- Як бачимо час витрачений на виконання алгоритмів істотно не відрізняється від попереднього номіналу, а отже він залежить тільки від суми.
